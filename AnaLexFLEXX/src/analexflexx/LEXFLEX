package analexflexx;
import static analexflexx.Tokens.*;
%%
%class Lexer
%type Tokens
L=[a-zA-Z_]+
S=[a-zA-Z_]
D=[0-9]+
N=[0-9]
espacio=[ ,\t,\r,\n]+
%{
    public String lexeme;
%}
%%
LOAD |
FROM |
EXPORT |
ROOT |
ENTE |
NUMB |
NUMBDEC |
LETTER |
WORDS |
CLEVER |
MUCUCK |
CTR |
ARQUI |
WRITING |
READING |
YES |
NOTY |
WORK |
CHECK |
FOR |
back |
CRAFT |
OF |
WITH |
true |
false |

while {lexeme=yytext(); return Reservadas;}
{N}{N}{N}{N}{N}{N}{N}{N}{S} {lexeme=yytext(); return DNI;}
"_/"{L}({L}|{D})*"\_" {lexeme=yytext(); return Comentario;}
"__/"{L}({L}|{D})*"\__" {lexeme=yytext(); return Comentario;}
{N}{N}"M"{N}{N}{N}{N} {lexeme=yytext(); return Matricula1;}
{L}{N}{N}{N} {lexeme=yytext(); return Matricula2;}
{N}{N}{N}{N}{N}{N} {lexeme=yytext(); return Matricula3;}
"CRE:"{N}{N} {lexeme=yytext(); return Credito;}
"CRE:"{N} {lexeme=yytext(); return Credito;}

{espacio} {/*Ignore*/}
"_/".* {/*Ignore*/}
"\_".* {/*Ignore*/}
"__/".* {/*Ignore*/}
"\__".* {/*Ignore*/}

"+" {return OperadorSuma;}
"-" {return OperadorResta;}
"@" {return OperadorMultiplicacion;}
"/" {return OperadorDivision;}
"$" {return OperadorPotencia;}
"-$-" {return OperadorRaiz;}
"#" {return OperadorResiduo;}
"&" {return OperadorLogico;}
"!!" {return OperadorLogico;}
"~" {return OperadorLogico;}
"==" {return OperadorRelacion;}
"!=" {return OperadorRelacion;}
">" {return OperadorRelacion;}
"<" {return OperadorRelacion;}
" <= " {return OperadorRelacion;}
" >= " {return OperadorRelacion;}
" <=> " {return OperadorAsignacion;}

{L}({L}|{D})*|"("{espacio}{L}({L}|{D})*{espacio}")" {lexeme=yytext(); return Identificador;}
"|"{L}({L}|{D})*"|"|"("{espacio}"|"{L}({L}|{D})*"|"{espacio}")" {lexeme=yytext(); return LiteralCadena;}
"‘"{S}"’" {lexeme=yytext(); return LiteralCaracter;}
("(-"{D}+"."{D}+")")|{D}+"."{D}+ {lexeme=yytext(); return LiteralNumeroReal;}
("(-"{D}+")")|{D}+ {lexeme=yytext(); return LiteralNumeroEntero;}

 . {return ERROR;}
